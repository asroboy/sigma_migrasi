/*
 * To change this license header, choose License Headers in Project Properties.
 * To change this template file, choose Tools | Templates
 * and open the template in the editor.
 */
package com.sigma.migrationtool.bkp;

import com.sigma.big.controller.MappingColumnController;
import com.sigma.big.controller.MappingMatrixController;
import com.sigma.big.model.db.DBConConfiguration;
import com.sigma.big.model.db.MappingColumn;
import com.sigma.big.model.db.MappingMatrix;
import com.sigma.big.utils.Activity;
import com.sigma.bigmigrasi.db.DBUtil;
import com.sigma.migrationtool.Main;
import com.vividsolutions.jts.geom.Geometry;
import com.vividsolutions.jts.io.ParseException;
import com.vividsolutions.jts.io.WKTReader;
import java.awt.Color;
import java.io.BufferedReader;
import java.io.IOException;
import java.io.Reader;
import java.sql.Clob;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.logging.Level;
import java.util.logging.Logger;
import javax.swing.table.DefaultTableModel;

/**
 *
 * @author Ridho
 */
public class MigrasiBigPanel extends javax.swing.JPanel implements Activity {

    /**
     * Creates new form MigrasiBig
     */
    ArrayList<MappingMatrix> mappingMatrixs;

    public MigrasiBigPanel() {
        initComponents();
    }

    private void showMappingListToCombo() {
        if (mappingMatrixs != null) {
            for (MappingMatrix dbConConf : mappingMatrixs) {
                comboMatrix.addItem(dbConConf.getName());
            }
        }
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents() {

        comboMatrix = new javax.swing.JComboBox<>();
        jLabel2 = new javax.swing.JLabel();
        jScrollPane1 = new javax.swing.JScrollPane();
        tableMatrix = new javax.swing.JTable();
        jButton3 = new javax.swing.JButton();
        buttonAmbilMatrix = new javax.swing.JButton();
        labelUrlSumber = new javax.swing.JLabel();
        labelTableSumber = new javax.swing.JLabel();
        labelUrlTarget = new javax.swing.JLabel();
        labelTabelTarget = new javax.swing.JLabel();
        jLabel3 = new javax.swing.JLabel();

        setBackground(new java.awt.Color(255, 255, 255));
        addFocusListener(new java.awt.event.FocusAdapter() {
            public void focusGained(java.awt.event.FocusEvent evt) {
                formFocusGained(evt);
            }
            public void focusLost(java.awt.event.FocusEvent evt) {
                formFocusLost(evt);
            }
        });
        addComponentListener(new java.awt.event.ComponentAdapter() {
            public void componentHidden(java.awt.event.ComponentEvent evt) {
                formComponentHidden(evt);
            }
            public void componentShown(java.awt.event.ComponentEvent evt) {
                formComponentShown(evt);
            }
        });

        jLabel2.setText("Mapping");

        tableMatrix.setModel(new javax.swing.table.DefaultTableModel(
            new Object [][] {
                {null, null},
                {null, null},
                {null, null},
                {null, null}
            },
            new String [] {
                "Sumber", "Target"
            }
        ) {
            Class[] types = new Class [] {
                java.lang.String.class, java.lang.String.class
            };

            public Class getColumnClass(int columnIndex) {
                return types [columnIndex];
            }
        });
        jScrollPane1.setViewportView(tableMatrix);

        jButton3.setFont(new java.awt.Font("Tahoma", 1, 11)); // NOI18N
        jButton3.setText("Migrate");
        jButton3.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                jButton3ActionPerformed(evt);
            }
        });

        buttonAmbilMatrix.setText("Ambil Matriks");
        buttonAmbilMatrix.addActionListener(new java.awt.event.ActionListener() {
            public void actionPerformed(java.awt.event.ActionEvent evt) {
                buttonAmbilMatrixActionPerformed(evt);
            }
        });

        labelUrlSumber.setText("Url sumber : ");

        labelTableSumber.setText("Table sumber : ");

        labelUrlTarget.setText("Url target :");

        labelTabelTarget.setText("Tabel target :");

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                        .addGap(179, 179, 179)
                        .addComponent(jButton3, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addGap(219, 219, 219))
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addGroup(layout.createSequentialGroup()
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(labelUrlSumber)
                                    .addComponent(labelTableSumber))
                                .addGap(201, 201, 201)
                                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                                    .addComponent(labelTabelTarget)
                                    .addComponent(labelUrlTarget))
                                .addGap(0, 0, Short.MAX_VALUE))
                            .addComponent(jScrollPane1, javax.swing.GroupLayout.DEFAULT_SIZE, 542, Short.MAX_VALUE)
                            .addGroup(layout.createSequentialGroup()
                                .addComponent(jLabel2)
                                .addGap(45, 45, 45)
                                .addComponent(comboMatrix, 0, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                            .addGroup(javax.swing.GroupLayout.Alignment.TRAILING, layout.createSequentialGroup()
                                .addGap(0, 0, Short.MAX_VALUE)
                                .addComponent(buttonAmbilMatrix)))
                        .addContainerGap())
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(jLabel3)
                        .addGap(0, 0, Short.MAX_VALUE))))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(comboMatrix, javax.swing.GroupLayout.PREFERRED_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.PREFERRED_SIZE)
                    .addComponent(jLabel2))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.UNRELATED)
                .addComponent(buttonAmbilMatrix)
                .addGap(14, 14, 14)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelUrlSumber, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(labelUrlTarget, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addGap(5, 5, 5)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                    .addComponent(labelTableSumber, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                    .addComponent(labelTabelTarget, javax.swing.GroupLayout.DEFAULT_SIZE, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE))
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane1, javax.swing.GroupLayout.PREFERRED_SIZE, 221, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jButton3, javax.swing.GroupLayout.PREFERRED_SIZE, 42, javax.swing.GroupLayout.PREFERRED_SIZE)
                .addGap(10, 10, 10)
                .addComponent(jLabel3)
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void formFocusGained(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_formFocusGained
        // TODO add your handling code here:


    }//GEN-LAST:event_formFocusGained

    private void formFocusLost(java.awt.event.FocusEvent evt) {//GEN-FIRST:event_formFocusLost
        // TODO add your handling code here:

    }//GEN-LAST:event_formFocusLost

    private void formComponentHidden(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentHidden
        // TODO add your handling code here:
        System.out.println("COMPONENT HIDDEN");
    }//GEN-LAST:event_formComponentHidden

    private void formComponentShown(java.awt.event.ComponentEvent evt) {//GEN-FIRST:event_formComponentShown
        // TODO add your handling code here:
        System.out.println("COMPONENT SHOWN");
    }//GEN-LAST:event_formComponentShown

    ArrayList<MappingColumn> mappingColumns;
    private void buttonAmbilMatrixActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_buttonAmbilMatrixActionPerformed
        // TODO add your handling code here:
        MappingColumnController mappingColumnController = new MappingColumnController(new DBUtil());
        try {

            MappingMatrix mappingMatrix = mappingMatrixs.get(comboMatrix.getSelectedIndex());
            mappingColumns = mappingColumnController.getAllMappingColumnByMappingMatrix(mappingMatrix);
            DefaultTableModel dtm = (DefaultTableModel) tableMatrix.getModel();
            dtm.setRowCount(mappingColumns.size());
            tableMatrix.setModel(dtm);

            int i = 0;
            for (MappingColumn mappingColumn : mappingColumns) {
                tableMatrix.getModel().setValueAt(mappingColumn.getColSourceName(), i, 0);
                tableMatrix.getModel().setValueAt(mappingColumn.getColTargetName(), i, 1);
                i++;
            }

            labelUrlSumber.setText("Url sumber :" + mappingMatrix.getConnSumber().getHost() + ":" + mappingMatrix.getConnSumber().getPort());
            labelUrlTarget.setText("Url target :" + mappingMatrix.getConnTarget().getHost() + ":" + mappingMatrix.getConnTarget().getPort());
            labelTableSumber.setText("Tabel sumber :" + mappingMatrix.getTableSource());
            labelTabelTarget.setText("Tabel target :" + mappingMatrix.getTableTarget());

        } catch (SQLException ex) {
            Logger.getLogger(MigrasiBigPanel.class.getName()).log(Level.SEVERE, null, ex);
        } catch (IOException ex) {
            Logger.getLogger(MigrasiBigPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }//GEN-LAST:event_buttonAmbilMatrixActionPerformed

    private void jButton3ActionPerformed(java.awt.event.ActionEvent evt) {//GEN-FIRST:event_jButton3ActionPerformed
        try {       // TODO add your handling code here:
            Connection conn = getConnection(mappingMatrixs.get(comboMatrix.getSelectedIndex()).getConnSumber());
            Statement stmt = conn.createStatement();
            String sql = generateSQLGetSource(mappingColumns);
            System.out.println(sql);
            ResultSet rs = stmt.executeQuery(sql);

            ArrayList<HashMap<String, Object>> sumberPacked = new ArrayList<>();
            ArrayList<HashMap<String, Object>> unmigratedRows = new ArrayList<>();
            boolean isGeometryCorrect = true;
            while (rs.next()) {

                HashMap<String, Object> dataSumber = new HashMap<>();
                int i = 0;

                for (MappingColumn mappingColumn : mappingColumns) {
                    String colSourceName = mappingColumn.getColSourceName();
                    String colSourceType = mappingColumn.getColSourceType();

                    if (colSourceType.equals("ST_GEOMETRY")) {
//                        String colValue = rs.getString(colSourceName);
                        try {
                            Clob colValue = rs.getClob(colSourceName);
                            String clobString = toString(colValue);
                            if (isGeometryKnown(clobString)) {
                                System.out.println("WKT STRING : " + clobString);
                                dataSumber.put(colSourceName, clobString);
                            } else {
                                isGeometryCorrect = false;
                                if (clobString.startsWith("(((", 0)) {
                                    int size = clobString.split(",")[0].split(" ").length;
                                    switch (size) {
                                        case 4:
                                            clobString = "MULTIPOLYGON Z " + clobString;
                                            break;
                                        case 5:
                                            clobString = "MULTIPOLYGON ZM " + clobString;
                                            break;
                                        default:
                                            clobString = "MULTIPOLYGON " + clobString;
                                            break;

                                    }

                                } else if (clobString.startsWith("((", 0)) {
                                    int size = clobString.split(",")[0].split(" ").length;
                                    switch (size) {
                                        case 4:
                                            clobString = "POLYGON Z " + clobString;
                                            break;
                                        case 5:
                                            clobString = "POLYGON ZM " + clobString;
                                            break;
                                        default:
                                            clobString = "POLYGON " + clobString;
                                            break;
                                    }

                                }

                                dataSumber.put(colSourceName, clobString);
                                System.err.println("UNKNOWN GEOMETRY " + clobString);

                            }
                        } catch (IOException ex) {
                            Logger.getLogger(MigrasiBigPanel.class.getName()).log(Level.SEVERE, null, ex);
                        }

                    } else {

                        String colValue = rs.getString(colSourceName);
                        System.out.println(colSourceName + " : " + colValue);
                        dataSumber.put(colSourceName, colValue);
                    }
                    i++;
                }
//                if (isGeometryCorrect) {
                sumberPacked.add(dataSumber);
//                } else {
                if (!isGeometryCorrect) {
                    unmigratedRows.add(dataSumber);
                }
                isGeometryCorrect = true;

            }
            conn.close();

//            for (HashMap<String, Object> unmigratedRow : unmigratedRows) {
//                System.out.println(unmigratedRow.get("OBJECTID"));
//            }
            migrasiToSdo(sumberPacked, unmigratedRows);
        } catch (SQLException ex) {
            Logger.getLogger(MigrasiBigPanel.class.getName()).log(Level.SEVERE, null, ex);
            jLabel3.setForeground(Color.red);
            jLabel3.setText("Koneksi gagal");
        }

    }//GEN-LAST:event_jButton3ActionPerformed

    public String toString(final Clob clob)
            throws SQLException, IOException {

        if (clob == null) {
            return "";
        }

        Long length = null;

        // try to get the oracle specific CLOB length
        // no vendor-specific code here.
        try {
            final Class<?> oracleClobClass = Class.forName("oracle.sql.CLOB");
            if (oracleClobClass.isInstance(clob)) {
                length = (Long) oracleClobClass.getMethod("getLength", null)
                        .invoke(clob, null);
            }
        } catch (final Exception e) {
        }

        // we can set initial capacity if we got the length.
        final StringBuilder builder
                = length == null
                        ? new StringBuilder() : new StringBuilder(length.intValue());

        final BufferedReader reader
                = new BufferedReader(clob.getCharacterStream());
        for (String line = null; (line = reader.readLine()) != null;) {
            builder.append(line);
        }

        return builder.toString();
    }

    public boolean isGeometryKnown(String wkt) {
        return (wkt.contains("LINESTRING") || wkt.contains("POLYGON") || wkt.contains("MULTIPOLYGON") || wkt.contains("POLYLINE") || wkt.contains("MULTIPOLYLINE") || wkt.contains("POINT") || wkt.contains("MULTIPOINT"));
    }

    public void migrasiToSdo(ArrayList<HashMap<String, Object>> dataSumber, ArrayList<HashMap<String, Object>> failedRows) {
        try {
            Connection conn = getConnection(mappingMatrixs.get(comboMatrix.getSelectedIndex()).getConnTarget());
            //            Statement stmt = conn.createStatement();
            String sql = generateSQLInsertTarget(mappingColumns);
            System.out.println(sql);
            PreparedStatement preparedStmt = conn.prepareStatement(sql);

            for (int j = 0; j < dataSumber.size(); j++) {
                String val = "";
                HashMap<String, Object> columnData = dataSumber.get(j);
                preparedStmt.setString(1, "7f998535-c813-11e6-9ff9-dc85de5cac37");
                System.out.println("add to prepared stmt index " + 1 + " val " + "7f998535-c813-11e6-9ff9-dc85de5cac37");

                int i = 1;
                for (MappingColumn mappingColumn : mappingColumns) {
                    boolean isGeomType = mappingColumn.getColSourceType().equals("ST_GEOMETRY");
                    boolean isNumber = mappingColumn.getColSourceType().equals("NUMBER");

                    if (isGeomType) {
                        Geometry geometri = getGeometry((String) columnData.get(mappingColumn.getColSourceName()));
                        System.out.println("add to prepared stmt index " + (i + 1) + mappingColumn.getColSourceName() + " val " + ((geometri == null) ? null : getGeometry((String) columnData.get(mappingColumn.getColSourceName()))));
                        Clob clob = conn.createClob();
                        String str = ((geometri == null) ? "" : getGeometry((String) columnData.get(mappingColumn.getColSourceName())).toString());
                        clob.setString(1, str);
                        preparedStmt.setClob(i + 1, clob); //getGeometry((String) columnData.get(mappingColumn.getColSourceName())
                        //OracleSpatialUtils.getOracleWkt().toText()
                    } else {
                        if (isNumber) {
                            System.out.println("add to prepared stmt index " + (i + 1) + mappingColumn.getColSourceName() + " val " + columnData.get(mappingColumn.getColSourceName()));
                            preparedStmt.setInt(i + 1, Integer.parseInt((String) columnData.get(mappingColumn.getColSourceName())));
                            //                            val += ((String) columnData.get(mappingColumn.getColSourceName()));
                            //                            val += (i == columnData.size() - 1 ? "" : ",");
                        } else {
                            System.out.println("add to prepared stmt index " + (i + 1) + mappingColumn.getColSourceName() + " val " + columnData.get(mappingColumn.getColSourceName()));
                            preparedStmt.setString(i + 1, (String) columnData.get(mappingColumn.getColSourceName()));
//                            val += "\'" + ((String) columnData.get(mappingColumn.getColSourceName())) + "\'";
//                            val += (i == columnData.size() - 1 ? "" : ",");
                        }
                    }

                    i++;
                }
                System.out.println("== ADD BATCH DATA == ");
                preparedStmt.addBatch();
//                System.out.println(sql);
//                stmt.executeLargeUpdate(sql);
            }

            preparedStmt.executeBatch();
            conn.close();

            jLabel3.setText("Selesai, Jumalh row berhasil : " + dataSumber.size() + ", Jumlah row yang tidak dapat di migrasi : " + failedRows.size());
        } catch (SQLException ex) {
            jLabel3.setForeground(Color.red);
            jLabel3.setText("Gagal");
            Logger
                    .getLogger(MigrasiBigPanel.class
                            .getName()).log(Level.SEVERE, null, ex);

        }
    }

    public Geometry getGeometry(String wkt) {
//        System.out.println("WKT " + wkt);
        if (wkt.equals("")) {
            return null;
        } else {
            if (wkt.contains("ZM")) {
                Geometry geom = null;
                String wkkt2 = wkt.replace("ZM", "");
                if (wkkt2.contains("1.#QNAN000")) {
                    wkkt2 = wkkt2.replace("1.#QNAN000", "");
                    WKTReader reader = new WKTReader();
                    try {
                        //INSERT GEOMETRI YG DIPEROLEH KE TABLE SDO --> ADMINISTRASI_LN_25K_SDO
                        geom = reader.read(wkkt2);
                        return geom;

                    } catch (ParseException ex) {
                        Logger.getLogger(Main.class
                                .getName()).log(Level.SEVERE, null, ex);

                    }
                }
                return geom;
            } else if (wkt.contains("Z")) {
                String wkkt2 = wkt.replace("Z", "");
                WKTReader reader = new WKTReader();
                try {
                    //INSERT GEOMETRI YG DIPEROLEH KE TABLE SDO --> ADMINISTRASI_LN_25K_SDO
                    Geometry geom = reader.read(wkkt2);
                    return geom;

                } catch (ParseException ex) {
                    Logger.getLogger(Main.class
                            .getName()).log(Level.SEVERE, null, ex);
                    return null;
                }

            } else {
//            com.esri.core.geometry.Geometry geo = WktWkbUtil.fromWkt(wkt);
                WKTReader reader = new WKTReader();
                try {
                    //INSERT GEOMETRI YG DIPEROLEH KE TABLE SDO --> ADMINISTRASI_LN_25K_SDO
                    Geometry geom = reader.read(wkt);
                    return geom;

                } catch (ParseException ex) {
                    Logger.getLogger(Main.class
                            .getName()).log(Level.SEVERE, null, ex);
                    return null;
                }
            }
        }

    }

    public Connection getConnection(DBConConfiguration dbcc) {
        DBUtil util = new DBUtil();
        String driverName = "oracle.jdbc.OracleDriver";
        String url = "";
        if (dbcc.getSid() != null) {
            url = "jdbc:oracle:thin:@"
                    + dbcc.getHost()
                    + ":" + dbcc.getPort()
                    + ":" + dbcc.getSid();
        }
        if (dbcc.getServiceName() != null) {
            url = "jdbc:oracle:thin:@//"
                    + dbcc.getHost()
                    + ":"
                    + dbcc.getPort()
                    + "/"
                    + dbcc.getServiceName();
        }

        System.out.println("DB URL : " + url);
        String username = dbcc.getUsername();
        String password = dbcc.getPassword();
        Connection con = util.getConnection(driverName, url, username, password);

        return con;
    }

    public String generateSQLInsertTarget(ArrayList<MappingColumn> mappingColumns) {
        String sql = "INSERT INTO " + mappingColumns.get(0).getMappingMatrix().getTableTarget() + " "
                + "(METADATA, ";
        int i = 0;
        String val = "";
        for (MappingColumn mappingColumn : mappingColumns) {
            sql += mappingColumn.getColTargetName() + (i == mappingColumns.size() - 1 ? "" : ",");
            if (mappingColumn.getColSourceType().equals("ST_GEOMETRY")) {
                val += "SDO_UTIL.FROM_WKTGEOMETRY(?)" + (i == mappingColumns.size() - 1 ? "" : ",");
            } else {
                val += "?" + (i == mappingColumns.size() - 1 ? "" : ",");
            }

            i++;
        }
        sql += ") VALUES (?, " + val + ")";
        return sql;
    }

    public String generateSQLGetSource(ArrayList<MappingColumn> mappingColumns) {
        String sql = "SELECT ";
        int i = 0;
        for (MappingColumn mappingColumn : mappingColumns) {
            boolean isGeomType = mappingColumn.getColSourceType().equals("ST_GEOMETRY");
            if (isGeomType) {
                sql += " SDE.ST_ASTEXT(";
            }
            if (i == mappingColumns.size() - 1) {
                sql += mappingColumn.getColSourceName() + (isGeomType ? ") AS " + mappingColumn.getColSourceName() : "");
            } else {
                sql += mappingColumn.getColSourceName() + (isGeomType ? ") AS " + mappingColumn.getColSourceName() + ", " : ", ");
            }
            i++;
        }

        sql += " FROM " + mappingColumns.get(0).getMappingMatrix().getTableSource();
        String whereClause = mappingColumns.get(0).getMappingMatrix().getWhereClause();
        sql += " " + whereClause == null ? whereClause : "";
//                + " WHERE OBJECTID =9";
//9 131 160 432

        return sql;
    }

    private String clobToString(Clob data) throws IOException {
        final StringBuilder sb = new StringBuilder();

        try {
            final Reader reader = data.getCharacterStream();
            final BufferedReader br = new BufferedReader(reader);

            int b;
            while (-1 != (b = br.read())) {
                sb.append((char) b);
            }

            br.close();
        } catch (SQLException e) {
            System.out.println("SQL. Could not convert CLOB to string " + e);
            return e.toString();
        } catch (IOException e) {
            System.out.println("IO. Could not convert CLOB to string " + e);
            return e.toString();
        }

        return sb.toString();
    }


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton buttonAmbilMatrix;
    private javax.swing.JComboBox<String> comboMatrix;
    private javax.swing.JButton jButton3;
    private javax.swing.JLabel jLabel2;
    private javax.swing.JLabel jLabel3;
    private javax.swing.JScrollPane jScrollPane1;
    private javax.swing.JLabel labelTabelTarget;
    private javax.swing.JLabel labelTableSumber;
    private javax.swing.JLabel labelUrlSumber;
    private javax.swing.JLabel labelUrlTarget;
    private javax.swing.JTable tableMatrix;
    // End of variables declaration//GEN-END:variables

    @Override
    public void onStart() {
        DBUtil dbu = new DBUtil();
        MappingMatrixController matrixController = new MappingMatrixController(dbu);
        try {
            comboMatrix.removeAllItems();
            mappingMatrixs = matrixController.getAllMappingColumnsAllRelations();
            showMappingListToCombo();
        } catch (Exception ex) {
            Logger.getLogger(MigrasiBigPanel.class.getName()).log(Level.SEVERE, null, ex);
        }
    }

    @Override
    public void onPause() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }

    @Override
    public void onResume() {
        throw new UnsupportedOperationException("Not supported yet."); //To change body of generated methods, choose Tools | Templates.
    }
}
